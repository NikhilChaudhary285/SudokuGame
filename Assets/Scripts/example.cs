/*using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using System.Linq;
using TMPro;
using UnityEditor.Tilemaps;

//using UnityEngine.UIElements;

public class ButtonReferencesGenerator : MonoBehaviour
{
	#region Lists of Rows
	List<int> r0 = new List<int>();
	List<int> r1 = new List<int>();
	List<int> r2 = new List<int>();
	List<int> r3 = new List<int>();
	List<int> r4 = new List<int>();
	List<int> r5 = new List<int>();
	List<int> r6 = new List<int>();
	List<int> r7 = new List<int>();
	List<int> r8 = new List<int>();
	#endregion

	#region Lists of Cols
	List<int> c0 = new List<int>();
	List<int> c1 = new List<int>();
	List<int> c2 = new List<int>();
	List<int> c3 = new List<int>();
	List<int> c4 = new List<int>();
	List<int> c5 = new List<int>();
	List<int> c6 = new List<int>();
	List<int> c7 = new List<int>();
	List<int> c8 = new List<int>();
	#endregion

	#region Lists of Grids
	List<int> g0 = new List<int>();
	List<int> g1 = new List<int>();
	List<int> g2 = new List<int>();
	List<int> g3 = new List<int>();
	List<int> g4 = new List<int>();
	List<int> g5 = new List<int>();
	List<int> g6 = new List<int>();
	List<int> g7 = new List<int>();
	List<int> g8 = new List<int>();
	#endregion

	// GridsButtons
	Button[] GridMainPanelDisplayButtons;

	#region usable after (Initializes Some Values)

	// Storing All Grids
	private GameObject[] Grids;

	// Each Grid MainCellButtons Count to full random values in it
	private Button[] EachGridMainCellButtons;

	// randomIndexList for storing values for grid and to give randomly
	List<int> randomIndexList;

	// GridReferences
	Dictionary<int, GameObject> GridReferences = new Dictionary<int, GameObject>();

	// GridButtonsInitializes
	List<Button[]> GridButtonsInitializes = new List<Button[]>();

	int GridMainCellButtonsArraySize;

	#endregion

	// ScriptsReferences Script
	[SerializeField]
	private ScriptsReferences scriptsReferences;

	// ButtonReferences : Main Dictionary To store ButtonReferences With Index
	[HideInInspector]
	public Dictionary<int, Button> ButtonReferences = new Dictionary<int, Button>();

	private void Awake()
	{
		// Creating SudokuObject
		SudokuObject sudokuObject = new SudokuObject();
		// GenerateRandomNumbers
		sudokuObject.GenerateRandomNumbers();

		// StoringListReferences of Buttons
		StoringListReferences();

		// Putting Random Values which generated by sudokuObject


		#region
		*//*Rows = new List<List<int>>() { r0, r1, r2, r3, r4, r5, r6, r7, r8 };
		Columns = new List<List<int>>() { c0, c1, c2, c3, c4, c5, c6, c7, c8 };
		Grids = new List<List<int>>() { g0, g1, g2, g3, g4, g5, g6, g7, g8 };*//*
		#endregion
		// ButtonReferencesIteratorWithIndexes
		//ButtonReferencesIteratorWithIndexes();
	}

	// Start is called before the first frame update
	void Start()
	{
		#region usable after (1
		*//*// For Only Getting Grids Count or Length
		Grids = GameObject.FindGameObjectsWithTag("Grid");

		// Gettings Each Grid MainCellButtons Count to fill random values in it
		EachGridMainCellButtons = Grids[0].GetComponentsInChildren<Button>();
		GridMainCellButtonsArraySize = EachGridMainCellButtons.Length;

		// ReinitializeListRandomList
		ReinitializeListRandomList(GridMainCellButtonsArraySize);

		// StoringGridReferences
		StoringGridReferences();

		// InitializingGridButtonsReferences
		InitializingGridButtonsReferences();*//*
		#endregion

		//AddListeners();

	}

	void StoringListReferences()
	{
		// buttonsGameObjectBaseName
		string buttonsGameObjectBaseName = "MainCell";
		// buttonsGameObject
		GameObject buttonsGameObject;
		// buttonReference
		Button buttonReference;

		for (int rows = 0; rows < 9; rows++)
		{
			for (int cols = 0; cols < 9; cols++)
			{
				// buttonsGameObjectName
				string buttonsGameObjectName = $"{rows}{cols}{buttonsGameObjectBaseName}";
				// buttonsGameObject
				buttonsGameObject = GameObject.Find(buttonsGameObjectName);
				// buttonReference
				buttonReference = buttonsGameObject.GetComponent<Button>();

				// dictionaryButtonIndexGenerator
				string dictionaryButtonIndexGenerator = $"{rows}{cols}";
				// dictionaryButtonIndexGeneratorValueInInt
				int dictionaryButtonIndexGeneratorValueInInt = int.Parse(dictionaryButtonIndexGenerator);

				ButtonReferences.Add(dictionaryButtonIndexGeneratorValueInInt, buttonReference);

				// Inserting Random Values also which generated by sudokuObject
				InsertingValues(rows, cols, buttonReference);

			}
		}
	}

	public void InsertingValues(int row, int column, Button buttonReference)
	{
		// Putting Random Values also which generated by sudokuObject
		int valueForbuttonReferenceText = SudokuObject.Values[row, column];
		if (valueForbuttonReferenceText != 0)
		{
			buttonReference.GetComponentInChildren<TMP_Text>().text = valueForbuttonReferenceText.ToString();
		}
		else
		{
			buttonReference.GetComponentInChildren<TMP_Text>().text = "";
		}
	}
	#region ButtonReferencesIteratorWithIndexes : Iterating ButtonReferences With Indexes
	void ButtonReferencesIteratorWithIndexes()
	{
		foreach (KeyValuePair<int, Button> ButtonReferencesValue in ButtonReferences)
		{
			Debug.Log($"ButtonReferencesKey: {ButtonReferencesValue.Key} ButtonReferencesValue: {ButtonReferencesValue.Value.gameObject.name}");

		}

	}
	#endregion

	#region usable after (1
	#region StoringGridReferences
	void StoringGridReferences()
	{
		string baseName = "Grid";
		for (int index = 0; index < Grids.Length; index++)
		{
			GridReferences.Add(index, GameObject.Find($"{index + 1}{baseName}")); //Grid || Index

		}
	}
	#endregion

	#region InitializingGridButtonsReferences
	void InitializingGridButtonsReferences()
	{
		GridButtonsInitializes.Add(GridReferences[0].GetComponentsInChildren<Button>()); //1GridButtonsElements || Index: 0
		GridButtonsInitializes.Add(GridReferences[1].GetComponentsInChildren<Button>()); //2GridButtonsElements || Index: 1
		GridButtonsInitializes.Add(GridReferences[2].GetComponentsInChildren<Button>()); //3GridButtonsElements || Index: 2
		GridButtonsInitializes.Add(GridReferences[3].GetComponentsInChildren<Button>()); //4GridButtonsElements || Index: 3
		GridButtonsInitializes.Add(GridReferences[4].GetComponentsInChildren<Button>()); //5GridButtonsElements || Index: 4
		GridButtonsInitializes.Add(GridReferences[5].GetComponentsInChildren<Button>()); //6GridButtonsElements || Index: 5
		GridButtonsInitializes.Add(GridReferences[6].GetComponentsInChildren<Button>()); //7GridButtonsElements || Index: 6
		GridButtonsInitializes.Add(GridReferences[7].GetComponentsInChildren<Button>()); //8GridButtonsElements || Index: 7
		GridButtonsInitializes.Add(GridReferences[8].GetComponentsInChildren<Button>()); //9GridButtonsElements || Index: 8

	}
	#endregion

	#region ReinitializeList (randomIndexList)
	void ReinitializeListRandomList(int GridMainCellButtonsArraySize)
	{
		randomIndexList = new List<int>();
		for (int i = 1; i < (GridMainCellButtonsArraySize + 1); i++)
		{
			randomIndexList.Add(i);
		}
	}
	#endregion

	#endregion

	#region For Button Value Comparisons

	#region IsNumberPossibleInPosition : Checking IsNumberPossibleInPosition, if userInputValueExist or Not in all comparisons : 1) For Row 2) For Col 3) For Grid according to this we can return true or false 
	public bool IsNumberPossibleInPosition(string userInput, int RowIndex, int ColIndex, Button userInputGridButton)
	{
		#region Checking IsNumberPossibleInPosition : if userInputValueExist or Not in all comparisons : 1) For Row 2) For Col 3) For Grid according to this we can return true or false 
		// if userInputValueNotExist then at that time we have checked all comparisons : 1) For Row 2) For Col 3) For Grid and we find that userInputValueNotExist in all these comparisons positions,
		// So we can put userInput in Selcted userInputGridButton with correct Color of Text
		// 1) For Row 2) For Col :->
		if (IsNumberPossibleInRow(userInput, RowIndex, userInputGridButton) && IsNumberPossibleInColumn(userInput, ColIndex, userInputGridButton))
		{
			// 3) For Grid :->
			if (IsNumberPossibleInGrid(userInput, userInputGridButton))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
		#endregion
	}
	#endregion

	#region IsNumberPossibleInRow : if userInputValueNotExist then check next logic : 1) For Row or Horizontally
	public bool IsNumberPossibleInRow(string userInput, int RowIndex, Button userInputGridButton)
	{
		#region RowWiseChecking For Loop : for Horizontal Comparisons
		for (int i = 0; i < 9; i++)
		{
			string RowIndexGenerator = $"{RowIndex}{i}";
			int ButtonReferenceRowIndex = int.Parse(RowIndexGenerator);

			if (ButtonReferences[ButtonReferenceRowIndex].GetComponentInChildren<TMP_Text>().text == userInput)
			{
				// Condition : To not execute below code for same selected userInputGridButton
				if (ButtonReferences[ButtonReferenceRowIndex] != userInputGridButton)
				{
					return false;
				}

			}
		}
		#endregion
		return true;
	}
	#endregion

	#region IsNumberPossibleInColumn : if userInputValueNotExist then check next logic : 2) For Column or Vertically
	public bool IsNumberPossibleInColumn(string userInput, int ColIndex, Button userInputGridButton)
	{
		#region ColumnWiseChecking For Loop : for Vertical Comparisons 
		for (int i = 0; i < 9; i++)
		{
			string ColIndexGenerator = $"{i}{ColIndex}";
			int ButtonReferenceColIndex = int.Parse(ColIndexGenerator);

			if (ButtonReferences[ButtonReferenceColIndex].GetComponentInChildren<TMP_Text>().text == userInput)
			{
				// Condition : To not execute below code for same selected userInputGridButton
				if (ButtonReferences[ButtonReferenceColIndex] != userInputGridButton)
				{
					return false;
				}

			}
		}
		#endregion
		return true;
	}
	#endregion

	#region IsNumberPossibleInGrid : if userInputValueNotExist then check next logic : 3) For Grid or GridButtonsWise || GridButtonsWiseChecking
	public bool IsNumberPossibleInGrid(string userInput, Button userInputGridButton)
	{
		// userInputGridButton
		GameObject SelectedGridFromButtonReference = userInputGridButton.transform.parent.parent.gameObject;
		// SelectedGridFromButtonReferenceButtons
		Button[] SelectedGridFromButtonReferenceButtons = SelectedGridFromButtonReference.GetComponentsInChildren<Button>();

		#region SelectedGridFromButtonReferenceButtons WiseChecking For Loop : for currentSelectedButtonGridButtons Comparisons 
		for (int SelectedGridFromButtonReferenceButtonIndex = 0; SelectedGridFromButtonReferenceButtonIndex < SelectedGridFromButtonReferenceButtons.Length; SelectedGridFromButtonReferenceButtonIndex++)
		{
			string GridButtonIndexGenerator = $"{SelectedGridFromButtonReferenceButtons[SelectedGridFromButtonReferenceButtonIndex].gameObject.name.Substring(0, 2)}";
			int ButtonReferenceGridButtonIndex = int.Parse(GridButtonIndexGenerator);

			if (ButtonReferences[ButtonReferenceGridButtonIndex].GetComponentInChildren<TMP_Text>().text == userInput)
			{
				// Condition : To not execute below code for same selected userInputGridButton
				if (ButtonReferences[ButtonReferenceGridButtonIndex] != userInputGridButton)
				{
					return false;
				}

			}
		}
		#endregion
		return true;
	}
	#endregion

	#endregion


}
*/

/*using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using System.Linq;
using TMPro;
using JetBrains.Annotations;

public class SudokoValidator : MonoBehaviour
{
	// GridMainPanelDisplay
	[SerializeField]
	private GameObject GridMainPanelDisplay;

	// GridsButtons
	Button[] GridMainPanelDisplayButtons;

	// ScriptsReferences Script
	[SerializeField]
	private ScriptsReferences scriptsReferences;

	#region ColorManagerForGridButtons
	// errorColorForGridMainDisplayButtonsForWrongInput
	Color errorColorForGridMainDisplayButtonsForWrongInput;

	// gridButtonSelectedColor
	Color gridButtonSelectedColor;

	// defaultColorForGridMainDisplayButtons
	Color defaultColorForGridMainDisplayButtons = Color.white;
	#endregion

	#region Initializes Some Values
	// Getting All Grids
	private GameObject[] Grids;

	// Each Grid MainCellButtons Count to full random values in it
	private Button[] EachGridMainCellButtons;

	// randomIndexList for storing values for grid and to give randomly
	List<int> randomIndexList;

	// GridReferences
	Dictionary<int, GameObject> GridReferences = new Dictionary<int, GameObject>();

	// GridButtonsInitializes
	List<Button[]> GridButtonsInitializes = new List<Button[]>();

	int GridMainCellButtonsArraySize;

	#endregion

	// ButtonReferences : Main Dictionary To store ButtonReferences With Index Grasping These ButtonReferences from ButtonReferences Script (Dictionary ButtonReferences)
	Dictionary<int, Button> ButtonReferences;

	// _userInputButton (Holding NormalUserInputButton Pressed)
	Button userInputButton;

	// userInputGridButton (Holding userInputGridButton Pressed)
	Button userInputGridButton;

	// Storing _userInputButton || UserInputButton's Value (Specific Value)
	string userInput;

	// Storing _userInputGridButton || _userInputGridButton's Value (Specific Value)
	string userInputGridButtonIndex;

	// userInputValueExist : To Check userInputValueExist or not it is responsible to tell how much logics have to be run for comparisons and the logics are: 1) For Row 2) For Col 3) For Grid Maybe
	bool userInputValueExist = false;

	#region InformationButton Concept
	// Button InformationButton
	[SerializeField]
	private Button InformationButton;

	// IsInformationButtonActive
	[HideInInspector]
	public bool IsInformationButtonActive = false;

	#endregion

	private void Awake()
	{
		// We performing this below initialization because we have to take this reference before start method calling
		// Storing GridMainPanelDisplayButtons
		GridMainPanelDisplayButtons = GridMainPanelDisplay.GetComponentsInChildren<Button>();

	}

	// Start is called before the first frame update
	void Start()
	{
		#region usable after (1
		*//*// For Only Getting Grids Count or Length
		Grids = GameObject.FindGameObjectsWithTag("Grid");

		// Gettings Each Grid MainCellButtons Count to fill random values in it
		EachGridMainCellButtons = Grids[0].GetComponentsInChildren<Button>();
		GridMainCellButtonsArraySize = EachGridMainCellButtons.Length;

		// ReinitializeListRandomList
		ReinitializeListRandomList(GridMainCellButtonsArraySize);

		// StoringGridReferences
		StoringGridReferences();

		// InitializingGridButtonsReferences
		InitializingGridButtonsReferences();*//*
		#endregion

		AddListeners();

		#region ColorManagerForGridButtons
		// errorColorForGridMainDisplayButtonsForWrongInput
		ColorUtility.TryParseHtmlString("#E32E2E", out errorColorForGridMainDisplayButtonsForWrongInput);

		// gridButtonSelectedColor
		ColorUtility.TryParseHtmlString("#A4D7E0", out gridButtonSelectedColor);
		#endregion

		// ButtonReferences : Main Dictionary To store ButtonReferences With Index Grasping These ButtonReferences from ButtonReferences Script (Dictionary ButtonReferences)
		ButtonReferences = scriptsReferences.buttonReferencesGenerator.ButtonReferences;

	}

	#region usable after (1
	#region StoringGridReferences
	void StoringGridReferences()
	{
		string baseName = "Grid";
		for (int index = 0; index < Grids.Length; index++)
		{
			GridReferences.Add(index, GameObject.Find($"{index + 1}{baseName}")); //Grid || Index

		}
	}
	#endregion

	#region InitializingGridButtonsReferences
	void InitializingGridButtonsReferences()
	{
		GridButtonsInitializes.Add(GridReferences[0].GetComponentsInChildren<Button>()); //1GridButtonsElements || Index: 0
		GridButtonsInitializes.Add(GridReferences[1].GetComponentsInChildren<Button>()); //2GridButtonsElements || Index: 1
		GridButtonsInitializes.Add(GridReferences[2].GetComponentsInChildren<Button>()); //3GridButtonsElements || Index: 2
		GridButtonsInitializes.Add(GridReferences[3].GetComponentsInChildren<Button>()); //4GridButtonsElements || Index: 3
		GridButtonsInitializes.Add(GridReferences[4].GetComponentsInChildren<Button>()); //5GridButtonsElements || Index: 4
		GridButtonsInitializes.Add(GridReferences[5].GetComponentsInChildren<Button>()); //6GridButtonsElements || Index: 5
		GridButtonsInitializes.Add(GridReferences[6].GetComponentsInChildren<Button>()); //7GridButtonsElements || Index: 6
		GridButtonsInitializes.Add(GridReferences[7].GetComponentsInChildren<Button>()); //8GridButtonsElements || Index: 7
		GridButtonsInitializes.Add(GridReferences[8].GetComponentsInChildren<Button>()); //9GridButtonsElements || Index: 8

	}
	#endregion

	#region ReinitializeList (randomIndexList)
	void ReinitializeListRandomList(int GridMainCellButtonsArraySize)
	{
		randomIndexList = new List<int>();
		for (int i = 1; i < (GridMainCellButtonsArraySize + 1); i++)
		{
			randomIndexList.Add(i);
		}
	}
	#endregion
	#endregion

	void AddListeners()
	{
		#region InformationButton Concept
		// IsInformationButtonActive
		InformationButton.onClick.AddListener(OnClick_InformationButton);
		#endregion
	}

	#region TakingUserInput
	public void TakingUserInput(Button _userInputButton)
	{
		userInputButton = _userInputButton;

		if (userInputGridButton != null)
		{
			// Calling UserInputAnalyzer Method : Whenever userGivingInput and with selected PressedGridButton
			UserInputAnalyzer(userInputButton, userInputGridButton);

		}
	}
	#endregion

	#region PressedGridButton
	public void PressedGridButton(Button _userInputGridButton)
	{
		userInputGridButton = _userInputGridButton;
	}
	#endregion

	#region UserInputAnalyzer
	void UserInputAnalyzer(Button _userInputButton, Button _userInputGridButton)
	{
		Debug.Log($"userInputButton: {_userInputButton.gameObject.name.Substring(0, 1)} userGridInput: {_userInputGridButton.gameObject.name.Substring(0, 2)}");

		userInputValueExist = false;

		// Storing userInput || UserInputButton's Value (Specific Value)
		userInput = _userInputButton.gameObject.name.Substring(0, 1);

		// Storing userInputGridButtonIndex For Comparisons Vertically, Horizontally or Grid Wise || _userInputGridButton's IndexValue (For: at which Specific Position that Button is exist IndexWise For Comparisons VHG Wise)
		userInputGridButtonIndex = _userInputGridButton.gameObject.name.Substring(0, 2);

		// Storing userInputGridButtonIndex In Integers For Comparisons Vertically and Horizontally by Splitting userInputGridButtonIndex in two Indexes like : 1) For Row 2) For Col 3) For Grid Maybe
		// RowIndex
		int RowIndex = int.Parse(userInputGridButtonIndex.Substring(0, 1));
		// ColIndex
		int ColIndex = int.Parse(userInputGridButtonIndex.Substring(1, 1));

		*//*** There are 3 Logics for check userInputValueExist or not : 1) For Row 2) For Col 3) For Grid ***//*

		#region FINALLY : Putting Correct Final Value With Correct Color of Text and Knowledge of IsInformationButtonActive or Not // if userInputValueNotExist then at that time we have checked all comparisons : 1) For Row 2) For Col 3) For Grid
		// if userInputValueNotExist then at that time we have checked all comparisons : 1) For Row 2) For Col 3) For Grid and we find that userInputValueNotExist in all these comparisons positions,
		// So we can put userInput in Selcted userInputGridButton with correct Color of Text
		// 1) For Row 2) For Col :->

		if (IsInformationButtonActive) // if InformationButtonActive then SetSmallNumber with correct Color of Text
		{
			// Putting (Information) UserInput In userInputGridButton but with correct Color of Text
			userInputGridButton.GetComponentInChildren<GridButtonSelector>().SetSmallNumber(userInput, Color.black);

		}
		else // else if InformationButtonNotActive then SetNumber but with specific Color of Text and Color concept is below
		{
			if (scriptsReferences.buttonReferencesGenerator.IsNumberPossibleInPosition(userInput, RowIndex, ColIndex, userInputGridButton))
			{
				// Putting UserInput In userInputGridButton but with correct Color of Text
				userInputGridButton.GetComponentInChildren<GridButtonSelector>().SetNumber(userInput, Color.black);
			}
			else
			{
				// Putting UserInput In userInputGridButton but with red Color of Text
				userInputGridButton.GetComponentInChildren<GridButtonSelector>().SetNumber(userInput, errorColorForGridMainDisplayButtonsForWrongInput);
			}
		}
		#endregion
	}

	#endregion

	#region InformationButton Concept

	#region OnClick_InformationButton
	public void OnClick_InformationButton()
	{
		if (!IsInformationButtonActive)
		{
			IsInformationButtonActive = true;
			InformationButton.GetComponent<Image>().color = gridButtonSelectedColor;
		}
		else
		{

			IsInformationButtonActive = false;
			InformationButton.GetComponent<Image>().color = defaultColorForGridMainDisplayButtons;
		}
	}
	#endregion

	#endregion

}*/

/*using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEditorInternal;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class SudokuObject
{
	public static int[,] Values = new int[9, 9];

	// GetGridIndex
	public static int GetGridIndex(int row, int column)
	{
		if (row < 3)
		{
			if (column < 3) { return 1; }
			if (column < 6) { return 2; }
			else { return 3; }
		}
		else if (row < 6)
		{
			if (column < 3) { return 4; }
			if (column < 6) { return 5; }
			else { return 6; }
		}
		else
		{
			if (column < 3) { return 7; }
			if (column < 6) { return 8; }
			else { return 9; }
		}
	}

	public void GetGridGroup(int grid, out int startRow, out int startColumn)
	{
		startRow = 0;
		startColumn = 0;
		switch (grid)
		{
			// To Represent All Grids Group by startRow & startColumn
			// For 1st Row Grids
			case 1:
				startRow = 0;
				startColumn = 0;
				break;
			case 2:
				startRow = 0;
				startColumn = 3;
				break;
			case 3:
				startRow = 0;
				startColumn = 6;
				break;
			// For 2nd Row Grids
			case 4:
				startRow = 3;
				startColumn = 0;
				break;
			case 5:
				startRow = 3;
				startColumn = 3;
				break;
			case 6:
				startRow = 3;
				startColumn = 6;
				break;
			// For 3rd Row Grids
			case 7:
				startRow = 6;
				startColumn = 0;
				break;

			case 8:
				startRow = 6;
				startColumn = 3;
				break;
			case 9:
				startRow = 6;
				startColumn = 6;
				break;

			default:
				break;
		}
	}

	public void GenerateRandomNumbers()
	{
		int randomValue = 0;
		for (int row = 0; row < 9; row++)
		{
			for (int column = 0; column < 9; column++)
			{
				for (int i = 1; i < 10; i++)
				{
					int value = i;
					if (IsNumberPossibleInPosition(value, row, column))
					{
						randomValue = value;
						SudokuObject.Values[row, column] = randomValue;
						break;
					}
				}

			}
		}
	}

	public void GivingValues()
	{

	}

	public void GivingListOfRandomValues()
	{
		//List<int> Group
	}

	#region For Putting Specific Random Values

	#region IsNumberPossibleInPosition : Checking IsNumberPossibleInPosition, if randomValueExist or Not in all comparisons : 1) For Row 2) For Col 3) For Grid according to this we can return true or false 
	public bool IsNumberPossibleInPosition(int value, int row, int column)
	{
		#region Checking IsNumberPossibleInPosition : if userInputValueExist or Not in all comparisons : 1) For Row 2) For Col 3) For Grid according to this we can return true or false 
		// if userInputValueNotExist then at that time we have checked all comparisons : 1) For Row 2) For Col 3) For Grid and we find that userInputValueNotExist in all these comparisons positions,
		// So we can put userInput in Selcted userInputGridButton with correct Color of Text
		// 1) For Row 2) For Col :->
		if (IsNumberPossibleInRow(value, row) && IsNumberPossibleInColumn(value, column))
		{
			// 3) For Grid :->
			if (IsNumberPossibleInGrid(value, row, column))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
		#endregion
	}
	#endregion

	#region IsNumberPossibleInRow : if randomValueNotExist then we can check next logic : 2) For Column or Vertically
	public bool IsNumberPossibleInRow(int value, int row)
	{
		#region RowWiseChecking For Loop : for Horizontal Comparisons
		for (int i = 0; i < 9; i++)
		{
			if (SudokuObject.Values[row, i] == value)
			{
				return false;
			}
		}
		#endregion
		return true;
	}
	#endregion

	#region IsNumberPossibleInColumn : if randomValueNotExist then check next logic : 3) For Grid
	public bool IsNumberPossibleInColumn(int value, int column)
	{
		#region ColumnWiseChecking For Loop : for Vertical Comparisons 
		for (int i = 0; i < 9; i++)
		{
			if (SudokuObject.Values[i, column] == value)
			{
				return false;
			}
		}
		#endregion
		return true;
	}
	#endregion

	#region IsNumberPossibleInGrid : if randomValueNotExist then check next logic : 3) For Grid Group || Grid's Inner Elements
	public bool IsNumberPossibleInGrid(int value, int row, int column)
	{
		// Getting GridIndex
		int GridIndex = SudokuObject.GetGridIndex(row, column);
		// Getting GridGroup
		GetGridGroup(GridIndex, out int startRow, out int StartColumn);

		for (int Row = startRow; Row < startRow + 3; Row++)
		{
			for (int Column = StartColumn; Column < StartColumn + 3; Column++)
			{
				if (SudokuObject.Values[Row, Column] == value)
				{
					return false;
				}
			}
		}
		return true;
	}
	#endregion

	#endregion

}*/

//
/*#region GenerateRandomNumbers
using System.Collections.Generic;
using System;
using UnityEngine;

public void GenerateRandomNumbers()
{
	//int totaliterantion = 0;

	// ReInitializingSudokuObjectValues or previously GeneratedExistingRandomNumbers in SudokuObject Values Array ( SudokuObject.Values[] )
	Values = new int[9, 9];

	randomValue = 0;

	// For Loop SequenceCell Iterator : To Iterate All Postions To Fill It With Correct Number
	for (int mainRow = 0; mainRow < 9; mainRow++)
	{
		for (int mainCol = 0; mainCol < 9; mainCol++)
		{
			// Storing Current CellIndexes (Position)
			// RowIndex
			RowIndex = mainRow;
			// ColIndex
			ColIndex = mainCol;

			// ReInitializingRandomList
			ReInitializingRandomList();
			// for loop : running 9 times only to get 9 different random numbers and with this also removing one random number each time
			for (int r = 0; r < 9; r++)
			{
				int index = UnityEngine.Random.Range(0, randomList.Count);
				randomValue = randomList[index];
				randomList.RemoveAt(index);

				randomValueExist = false;

				//*** There are 3 Logics for check userInputValueExist or not : 1) For Row 2) For Col 3) For Grid ***/

				/*#region IsNumberPossibleInRow : if randomValueNotExist then check next logic : 1) For Row or Horizontally
				if (!randomValueExist)
				{
					#region RowWiseChecking For Loop : for Horizontal Comparisons
					for (int col = 0; col < 9; col++)
					{
						if (Values[RowIndex, col] == randomValue)
						{
							randomValueExist = true;
							break;
						}

					}
					#endregion
				}
				#endregion

				#region IsNumberPossibleInColumn : if randomValueNotExist then check next logic : 2) For Column or Vertically
				if (!randomValueExist)
				{
					#region ColumnWiseChecking For Loop : for Vertical Comparisons 
					for (int row = 0; row < 9; row++)
					{
						if (Values[row, ColIndex] == randomValue)
						{
							randomValueExist = true;
							break;
						}
					}
					#endregion
				}
				#endregion

				#region IsNumberPossibleInGrid : if randomValueNotExist then check next logic : 3) For Grid or GridCellsWise || GridCellsWiseChecking
				if (!randomValueExist)
				{
					// GetGridIndex
					int gridIndex = GetGridIndex(RowIndex, ColIndex);
					// Getting List of Tuple i.e. indexes of Current Grid (GridCells)
					List<Tuple<int, int>> gridCells = Grids[gridIndex];

					#region GridWiseChecking For Loop : For GridWise Comparisons (GridCellsWise || GridCellsWiseChecking)
					for (int gridCellIndex = 0; gridCellIndex < gridCells.Count; gridCellIndex++)
					{
						//Debug.Log($"[{gridCells[gridCellIndex].Item1}][{gridCells[gridCellIndex].Item2}]");
						int gridCellRowIndex = gridCells[gridCellIndex].Item1; // Represent RowIndex of GridCell
						int gridCellColIndex = gridCells[gridCellIndex].Item2; // Represent ColIndex of GridCell

						if (Values[gridCellRowIndex, gridCellColIndex] == randomValue)
						{
							randomValueExist = true;
							break;
						}
					}
					#endregion
				}
				#endregion

				// Finally : if randomValueNotExist In all Comparisons : 1) For Row (In RowWise), 2) For Column (In ColWise) 3) For Grid (In GridWise) || GridWiseElements, then simply put that value
				if (!randomValueExist)
				{
					Values[RowIndex, ColIndex] = randomValue;
					break;
				}
				*//*else
				{
					// Removing previously selected random number which isn't capable to insert at specific position and after that we can select from randomList in which this index's random value doesn't exist
					//totaliterantion++;
					SwapPositionsMachine(new Tuple<int, int>(RowIndex, ColIndex), randomValue);
				}*//*

			}
			// if randomValueExist, then call SwapPositionsMachine() Method
			if (randomValueExist)
			{
				Debug.Log($"[{RowIndex}][{ColIndex}]");
				forloopValue = 0;
				stopExecution = false;
				for (int i = 1; i < 10; i++)
				{
					if (!stopExecution)
					{
						Debug.Log("ok");
						//sudokuFieldIndex = -1;
						forloopValue = i;
						//Debug.Log(forloopValue);
						SwapPositionsMachine(new Tuple<int, int>(RowIndex, ColIndex), forloopValue);
					}
					else
					{
						sudokuFieldIndex = -1;
						break;
					}
				}
			}
			sudokuFieldIndex = -1;
		}

	}
	//Debug.Log("totaliterations : " + totaliterantion);
}
#endregion*/
//*/